<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>经年</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://feahter.github.io/"/>
  <updated>2016-10-12T04:43:56.044Z</updated>
  <id>https://feahter.github.io/</id>
  
  <author>
    <name>Feahter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阴阳师-探索-妖怪分布统计</title>
    <link href="https://feahter.github.io/2016/10/12/%E9%98%B4%E9%98%B3%E5%B8%88-%E6%8E%A2%E7%B4%A2-%E5%A6%96%E6%80%AA%E5%88%86%E5%B8%83%E7%BB%9F%E8%AE%A1/"/>
    <id>https://feahter.github.io/2016/10/12/阴阳师-探索-妖怪分布统计/</id>
    <published>2016-10-12T04:29:45.000Z</published>
    <updated>2016-10-12T04:43:56.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阴阳师-探索-妖怪分布统计"><a href="#阴阳师-探索-妖怪分布统计" class="headerlink" title="阴阳师-探索-妖怪分布统计"></a>阴阳师-探索-妖怪分布统计</h1><h2 id="探索副本第一章"><a href="#探索副本第一章" class="headerlink" title="探索副本第一章"></a>探索副本第一章</h2><p>天邪鬼绿1——天邪鬼绿x1、提灯小僧x2</p>
<p>天邪鬼绿2——天邪鬼绿x1、灯笼鬼x2</p>
<p>提灯小僧1——天邪鬼绿x2、提灯小僧x1</p>
<p>提灯小僧2——灯笼鬼x2、提灯小僧x1</p>
<p>首领：九命猫——九命猫x3</p>
<h2 id="探索副本第二章"><a href="#探索副本第二章" class="headerlink" title="探索副本第二章"></a>探索副本第二章</h2><p>帚神——帚神x1、寄生魂x1、盗墓小鬼x1</p>
<p>盗墓小鬼1——寄生魂x2、盗墓小鬼x1</p>
<p>盗墓小鬼2——灯笼鬼x2、盗墓小鬼x1</p>
<p>寄生魂1——灯笼鬼x2、寄生魂x1</p>
<p>寄生魂2——盗墓小鬼x2、寄生魂x1</p>
<p>首领：座敷童子——座敷童子x1、天邪鬼绿x2、天邪鬼青x1</p>
<h2 id="探索副本第三章"><a href="#探索副本第三章" class="headerlink" title="探索副本第三章"></a>探索副本第三章</h2><p>天邪鬼黄1——天邪鬼黄x1、帚神x2、涂壁x1</p>
<p>天邪鬼黄2——天邪鬼黄x1、童女x3</p>
<p>赤舌1——赤舌x1、提灯小僧x1、灯笼鬼x2 、二回合 鸦天狗</p>
<p>赤舌2——赤舌x1、鬼黄x1、童女x2 二回合 鸦天狗</p>
<p>兵俑1——兵俑x1、提灯小僧x1、童女x2</p>
<p>兵俑2——兵俑x1、提灯小僧x1、灯笼鬼x2</p>
<p>首领：凤凰火——凤凰火x1 寄生魂x3</p>
<h2 id="探索副本第四章"><a href="#探索副本第四章" class="headerlink" title="探索副本第四章"></a>探索副本第四章</h2><p>帚神1——帚神x1、涂壁x2</p>
<p>帚神2——帚神x1、涂壁x1、唐纸伞妖x2</p>
<p>唐纸伞妖1——唐纸伞妖x1、天邪鬼赤x3</p>
<p>唐纸伞妖2——唐纸伞妖x1、天邪鬼赤x1、涂壁x2</p>
<p>天邪鬼赤1——天邪鬼赤x1、唐纸伞妖x1、涂壁x2</p>
<p>天邪鬼赤2——天邪鬼赤x1、唐纸伞妖x2</p>
<p>首领：雨女——雨女x1、青蛙瓷器x1、帚神x2</p>
<h2 id="探索副本第五章"><a href="#探索副本第五章" class="headerlink" title="探索副本第五章"></a>探索副本第五章</h2><p>涂壁1——涂壁x1、源博雅的神兽(?)x1、天邪鬼赤x2</p>
<p>涂壁2——涂壁x1、天邪鬼赤x3</p>
<p>帚神1——帚神x1、天邪鬼赤x1、涂壁x2</p>
<p>帚神2——帚神x1、天邪鬼赤x1、天邪鬼黄x2</p>
<p>管狐1——管狐x2、天邪鬼黄x2 二回合 寄生魂x1</p>
<p>管狐2——管狐x1、天邪鬼绿x3 二回合 寄生魂x1</p>
<p>首领：食发鬼——食发鬼x1、灯笼鬼x1、天邪鬼青x2</p>
<h2 id="探索副本第六章"><a href="#探索副本第六章" class="headerlink" title="探索副本第六章"></a>探索副本第六章</h2><p>灯笼鬼——灯笼鬼x1、帚神x3</p>
<p>天邪鬼青——天邪鬼青x1、天邪鬼绿x3</p>
<p>蝴蝶精——蝴蝶精x1、涂壁x1、天邪鬼赤x2 二回合 三尾狐x1</p>
<p>首领：巫蛊师——巫蛊师x1、天邪鬼绿x3</p>
<h2 id="探索副本第七章"><a href="#探索副本第七章" class="headerlink" title="探索副本第七章"></a>探索副本第七章</h2><p>鲤鱼精1——鲤鱼精x3、帚神x1</p>
<p>鲤鱼精2——鲤鱼精x1、帚神x3</p>
<p>河童1——河童x1、鲤鱼精x1、涂壁x2</p>
<p>河童2——河童x1、灯笼鬼x1、跳跳犬x2</p>
<p>提灯小僧12——提灯小僧x1、跳跳犬x3、二回合-管狐x1</p>
<p>提灯小僧3——提灯小僧x1、跳跳犬x1、鲤鱼精x2、二回合-管狐x1</p>
<p>首领：妖狐——妖狐x1、涂壁x1、座敷童子x2、二回合-管狐x1、寄生魂x1、天邪鬼赤x2</p>
<h2 id="探索副本第八章"><a href="#探索副本第八章" class="headerlink" title="探索副本第八章"></a>探索副本第八章</h2><p>唐纸伞妖1——伞妖x1、帚神x3</p>
<p>唐纸伞妖2——伞妖x1、山童x1、帚神x2</p>
<p>樱花妖1——樱花妖x1、帚神x1、涂壁x2、二回合-雪女x1</p>
<p>樱花妖2——樱花妖x1、涂壁x3、二回合-雪女x1</p>
<p>天邪鬼绿——天邪鬼绿x1、天邪鬼青x1、天邪鬼黄x2</p>
<p>首领：桃花妖——桃花妖x1、天邪鬼青x1、提灯小僧x2、二回合-樱花妖x1、帚神x1、蝴蝶精x2</p>
<h2 id="探索副本第九章"><a href="#探索副本第九章" class="headerlink" title="探索副本第九章"></a>探索副本第九章</h2><p>提灯小僧1——提灯小僧x1、灯笼鬼x3</p>
<p>提灯小僧2——提灯小僧x1、灯笼鬼x1、铁鼠x2</p>
<p>铁鼠1——铁鼠x1、帚神x3</p>
<p>铁鼠2——铁鼠x2、帚神x2</p>
<p>山兔1——山兔x3、铁鼠x1、二回合-鸦天狗</p>
<p>山兔2——山兔x4、二回合-鸦天狗</p>
<p>首领：孟婆——孟婆x1、饿鬼x3、二回合-孟婆x1、灯笼鬼x1、鸦天狗x2</p>
<h2 id="探索副本第十章"><a href="#探索副本第十章" class="headerlink" title="探索副本第十章"></a>探索副本第十章</h2><p>丑时之女——丑时之女x1、傀儡师x1、天邪鬼青x2</p>
<p>傀儡师1——傀儡师x1、觉x1、狸猫x2</p>
<p>傀儡师2——傀儡师x1、觉x1、座敷童子x2、二回合-犬神x1</p>
<p>觉1——觉x1、狸猫x3</p>
<p>觉2——觉x1、赤舌x1、座敷童子x2、二回合-犬神x1</p>
<p>首领：酒吞童子——酒吞童子x1、跳跳哥哥x1、食发鬼x2、二回合-酒吞童子x1、兵俑x1、骨女x2</p>
<h2 id="探索副本第十一章"><a href="#探索副本第十一章" class="headerlink" title="探索副本第十一章"></a>探索副本第十一章</h2><p>武士之灵1——武士之灵x1、寄生魂x3</p>
<p>武士之灵2——武士之灵x1、独眼小僧x3</p>
<p>独眼小僧1——独眼小僧x1、涂壁x1、天邪鬼赤x2</p>
<p>独眼小僧2——独眼小僧x1、管狐x1、天邪鬼赤x2</p>
<p>饿鬼1——饿鬼x1、涂壁x1、管狐x2</p>
<p>饿鬼2——饿鬼x3、管狐x1</p>
<p>首领：鬼女红叶——鬼女红叶x1、童女x1、天邪鬼青x2、二回合-鬼女红叶x1、骨女x1、觉x2</p>
<h2 id="探索副本第十二章"><a href="#探索副本第十二章" class="headerlink" title="探索副本第十二章"></a>探索副本第十二章</h2><p>海坊主1——海坊主x1、帚神x1、涂壁x2</p>
<p>海坊主2——海坊主x1、涂壁x1、鸦天狗x2</p>
<p>童男1——童男x1、天邪鬼黄x1、鸦天狗x2</p>
<p>童男2——童男x1、童女x1、鸦天狗x2</p>
<p>童女1——童女x1、盗墓小鬼x1、提灯小僧x2、二回合-雪女x1</p>
<p>童女2——童女x3、盗墓小鬼x1、二回合-雪女x1</p>
<p>首领：雪女——雪女x1、寄生魂x1、武士之灵x2、二回合-雪女x1、跳跳妹妹x1、跳跳哥哥x2</p>
<h2 id="探索副本第十三章"><a href="#探索副本第十三章" class="headerlink" title="探索副本第十三章"></a>探索副本第十三章</h2><p>饿鬼12——饿鬼x1 、天邪鬼赤x3</p>
<p>饿鬼3——饿鬼x1 、天邪鬼赤x3、二回合-首无x1</p>
<p>唐纸伞妖12——唐纸伞妖x1、鬼赤x1、天邪鬼绿x2</p>
<p>唐纸伞妖3——唐纸伞妖x1、鬼赤x1、天邪鬼绿x2、二回合-首无x1</p>
<p>首领：首无——首无x1、骨女x1、灯笼鬼x1、山兔x1</p>
<h2 id="探索副本第十四章"><a href="#探索副本第十四章" class="headerlink" title="探索副本第十四章"></a>探索副本第十四章</h2><p>帚神123——帚神x1、天邪鬼赤x3</p>
<p>涂壁12——涂壁x6</p>
<p>涂壁3——涂壁x6、二回合-食梦貘x1</p>
<p>首领：食梦貘——食梦貘x1、天邪鬼赤x3、二回合-食梦貘x4</p>
<h2 id="探索副本第十五章"><a href="#探索副本第十五章" class="headerlink" title="探索副本第十五章"></a>探索副本第十五章</h2><p>天邪鬼绿123——天邪鬼绿x1、赤舌x1、天邪鬼赤x2</p>
<p>提灯小僧12——提灯小僧x1、赤舌x1、九命猫x2</p>
<p>提灯小僧3——提灯小僧x1、赤舌x1、九命猫x2、二回合-大天狗x1</p>
<p>首领：跳跳妹妹——跳跳妹妹x1、九命猫x3</p>
<h2 id="探索副本第十六章"><a href="#探索副本第十六章" class="headerlink" title="探索副本第十六章"></a>探索副本第十六章</h2><p>饿鬼123——饿鬼x1、山兔x1、山童x2</p>
<p>赤舌12——赤舌x1、寄生魂x3</p>
<p>赤舌3——赤舌x1、寄生魂x3、二回合-赤舌x1</p>
<p>首领：判官——判官x1、小黑x1、小白x1</p>
<h2 id="探索副本第十七章"><a href="#探索副本第十七章" class="headerlink" title="探索副本第十七章"></a>探索副本第十七章</h2><p>鸦天狗123——鸦天狗x1、觉醒风小怪x3</p>
<p>狸猫12——狸猫x1、觉醒火小怪x3</p>
<p>狸猫3——狸猫x1、觉醒火小怪x3、二回合-暗凤凰(?)x1</p>
<p>首领：荒川之主——荒川之主x1、灯笼鬼x1、骨女x1、山兔x1</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阴阳师-探索-妖怪分布统计&quot;&gt;&lt;a href=&quot;#阴阳师-探索-妖怪分布统计&quot; class=&quot;headerlink&quot; title=&quot;阴阳师-探索-妖怪分布统计&quot;&gt;&lt;/a&gt;阴阳师-探索-妖怪分布统计&lt;/h1&gt;&lt;h2 id=&quot;探索副本第一章&quot;&gt;&lt;a href=&quot;#探索
    
    </summary>
    
      <category term="杂" scheme="https://feahter.github.io/categories/%E6%9D%82/"/>
    
    
      <category term="游戏" scheme="https://feahter.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>ST3私人定制</title>
    <link href="https://feahter.github.io/2016/09/13/ST3%E7%A7%81%E4%BA%BA%E5%AE%9A%E5%88%B6/"/>
    <id>https://feahter.github.io/2016/09/13/ST3私人定制/</id>
    <published>2016-09-13T09:27:29.000Z</published>
    <updated>2016-10-12T04:43:56.965Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ST3的私人订制。</strong></p>
<h2 id="一、官网下载安装"><a href="#一、官网下载安装" class="headerlink" title="一、官网下载安装"></a>一、官网下载安装</h2><p><strong>1.</strong><a href="http://www.sublimetext.com/3" target="_blank" rel="external"><strong>官网</strong></a><strong>下载。</strong></p>
<p><strong>2.软件安装。</strong></p>
<h2 id="二、正版激活"><a href="#二、正版激活" class="headerlink" title="二、正版激活"></a>二、正版激活</h2><p><strong>Sublime Text 3 许可证</strong></p>
<p><em>—– BEGIN LICENSE —–</em><br><em>Nicolas Hennion</em><br><em>Single User License</em><br><em>EA7E-866075</em><br><em>8A01AA83 1D668D24 4484AEBC 3B04512C</em><br><em>827B0DE5 69E9B07A A39ACCC0 F95F5410</em><br><em>729D5639 4C37CECB B2522FB3 8D37FDC1</em><br><em>72899363 BBA441AC A5F47F08 6CD3B3FE</em><br><em>CEFB3783 B2E1BA96 71AAF7B4 AFB61B1D</em><br><em>0CC513E7 52FF2333 9F726D2C CDE53B4A</em><br><em>810C0D4F E1F419A3 CDA0832B 8440565A</em><br><em>35BF00F6 4CA9F869 ED10E245 469C233E</em><br><em>—— END LICENSE ——</em></p>
<p><strong>1.打开Sublime菜单 &gt; help &gt; enter License</strong></p>
<p><strong>2.复制填入如上许可证或自行搜索一枚，确认激活。</strong></p>
<h2 id="三、插件管理器安装"><a href="#三、插件管理器安装" class="headerlink" title="三、插件管理器安装"></a>三、插件管理器安装</h2><p><strong>1.<code>ctrl+~</code> 打开ST自带控制台，复制如下代码至输入框，回车等待。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'2915d1851351e5ee549c20394736b442'</span> + <span class="string">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)</div></pre></td></tr></table></figure>
<p><strong>2.安装完成后，重启ST，至工具栏 Preferences 见到Package Control 项即安装成功</strong>。(</p>
<p>Package Control 用于ST插件的管理，安装、卸载、更新等工作。</p>
<p>)</p>
<h2 id="四、插件安装"><a href="#四、插件安装" class="headerlink" title="四、插件安装"></a>四、插件安装</h2><p><strong>1.插件安装</strong><br><code>Ctrl+Shift+P</code>打开插件管理器，输入框输入install，选择安装插件功能，等待弹出安装框，复制或填入要安装的插件名称，回车等待。(每一个插件安装的过程如上，部分安装不了的可能需要科学上网。)<br><strong>插件表：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">插件</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ChineseLocalization</td>
<td style="text-align:center">汉化</td>
</tr>
<tr>
<td style="text-align:center">HTML5</td>
<td style="text-align:center">H5标签拓展</td>
</tr>
<tr>
<td style="text-align:center">JsFormat</td>
<td style="text-align:center">javascript格式化</td>
</tr>
<tr>
<td style="text-align:center">CSS Format</td>
<td style="text-align:center">CSS</td>
</tr>
<tr>
<td style="text-align:center">Tag</td>
<td style="text-align:center">HTML</td>
</tr>
<tr>
<td style="text-align:center">Brackethighlighter</td>
<td style="text-align:center">标签对标记</td>
</tr>
<tr>
<td style="text-align:center">styleToken</td>
<td style="text-align:center">标记颜色代码</td>
</tr>
<tr>
<td style="text-align:center">SideBarEnhancements</td>
<td style="text-align:center">增强型侧边栏</td>
</tr>
<tr>
<td style="text-align:center">BufferScroll</td>
<td style="text-align:center">代码折叠状态保留</td>
</tr>
<tr>
<td style="text-align:center">Emmet</td>
<td style="text-align:center">前端神器</td>
</tr>
<tr>
<td style="text-align:center">FileHeader</td>
<td style="text-align:center">文件模板，保存文件修改时间</td>
</tr>
<tr>
<td style="text-align:center">Better Completion</td>
<td style="text-align:center">全能代码提示</td>
</tr>
<tr>
<td style="text-align:center">ConvertToUTF8</td>
<td style="text-align:center">GBK编码兼容</td>
</tr>
<tr>
<td style="text-align:center">PackageResourceViewer</td>
<td style="text-align:center">插件</td>
</tr>
</tbody>
</table>
<p><strong>2.用户设置</strong></p>
<p>工具栏 Preferences – Settings-User，打开用户设置文件<br>选择性填入如下内容：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">"trim_trailing_white_space_on_save": true,</div><div class="line">"ensure_newline_at_eof_on_save": true,</div><div class="line">"translate_tabs_to_spaces": true,</div><div class="line">"tab_size": 2,</div><div class="line">"draw_minimap_border": true,</div><div class="line">"save_on_focus_lost": true,</div><div class="line">"highlight_line": true,</div><div class="line">"word_wrap": "true",</div><div class="line">"fade_fold_buttons": false,</div><div class="line">"bold_folder_labels": true,</div><div class="line">"highlight_modified_tabs": true,</div><div class="line">"default_line_ending": "unix", </div><div class="line">"auto_find_in_selection": true</div></pre></td></tr></table></figure></p>
<p>trim_trailing_white_space_on_save,自动移除行尾多余空格。<br>ensure_newline_at_eof_on_save,文件末尾自动保留一个空行，防止文件在某些开发环境失效。<br>translate_tabs_to_spaces,代码 tab 对齐转换为空格对齐，<br>tab_size,配合设置空格数。这个需求因人而异了，不喜欢可以去掉。<br>draw_minimap_border,用于右侧代码预览时给所在区域加上边框，方便识别。<br>save_on_focus_lost,窗口失焦立即保存文件，嘛嘛再也不用担心你忘记保存了。<br>highlight_line,当前行高亮。<br>word_wrap,设置自动换行。<br>fade_fold_buttons,默认显示行号右侧的代码段闭合展开三角号。<br>bold_folder_labels,侧边栏文件夹显示加粗，区别于文件。<br>highlight_modified_tabs,高亮未保存文件。<br>default_line_ending: “unix”,使用 unix 风格的换行符。<br>auto_find_in_selection: true,开启选中范围内搜索(而不是整个文档)</p>
<p><strong>3.快捷键设置</strong></p>
<p>工具栏 Preferences – key Bindings-User 打开用户按键绑定</p>
<p>选择性填入如下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123; "keys": ["alt+space"], "command": "auto_complete" &#125;,</div><div class="line">&#123; "keys": ["alt+space"], "command": "replace_completion_with_auto_complete", "context":</div><div class="line">  [</div><div class="line">    &#123; "key": "last_command", "operator": "equal", "operand": "insert_best_completion" &#125;,</div><div class="line">    &#123; "key": "auto_complete_visible", "operator": "equal", "operand": false &#125;,</div><div class="line">    &#123; "key": "setting.tab_completion", "operator": "equal", "operand": true &#125;</div><div class="line">  ]</div><div class="line">&#125;,</div><div class="line">&#123; "keys": ["ctrl+alt+d"], "command": "goto_definition" &#125;,</div></pre></td></tr></table></figure>
<p>ST3默认的代码提示快捷键为 <code>ctrl + space</code> ，但是这个快捷键在天朝一直都被输入法霸占Mac用户泥奏凯 ，修改快捷键为 <code>alt+space</code> 。<br>ST3自带跳转到函数或CSS定义功能，在DreamWeaver中使用 <code>ctrl+d</code> 打开CSS样式定义源面板。</p>
<p>使用<code>ctrl+alt+d</code> 定义这个功能，ST3默认的 <code>ctrl+d</code> 已有选择相同字符的用途。</p>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>ctrl+shift+p</strong></td>
<td style="text-align:center">所有命令</td>
</tr>
<tr>
<td style="text-align:center">ctrl+g</td>
<td style="text-align:center">跳转行</td>
</tr>
<tr>
<td style="text-align:center">ctrl+/</td>
<td style="text-align:center">注释</td>
</tr>
<tr>
<td style="text-align:center">ctrl+d</td>
<td style="text-align:center">选择相同字符</td>
</tr>
<tr>
<td style="text-align:center">ctrl+shift+up/down</td>
<td style="text-align:center">整行移动</td>
</tr>
<tr>
<td style="text-align:center">ctrl+alt+right</td>
<td style="text-align:center">跳到下一个编辑点</td>
</tr>
<tr>
<td style="text-align:center">ctrl+u</td>
<td style="text-align:center">图片原始大小更新</td>
</tr>
<tr>
<td style="text-align:center">ctrl+shift+g</td>
<td style="text-align:center">批量格式生成</td>
</tr>
<tr>
<td style="text-align:center">ctrl+shift+y</td>
<td style="text-align:center">直接公式计算</td>
</tr>
<tr>
<td style="text-align:center">ctrl+up</td>
<td style="text-align:center">CSS数值加减1（alt+up 数值加减0.1）</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ST3的私人订制。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、官网下载安装&quot;&gt;&lt;a href=&quot;#一、官网下载安装&quot; class=&quot;headerlink&quot; title=&quot;一、官网下载安装&quot;&gt;&lt;/a&gt;一、官网下载安装&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.&lt;/
    
    </summary>
    
      <category term="器" scheme="https://feahter.github.io/categories/%E5%99%A8/"/>
    
    
      <category term="sublime" scheme="https://feahter.github.io/tags/sublime/"/>
    
  </entry>
  
  <entry>
    <title>jQuery操作dom元素</title>
    <link href="https://feahter.github.io/2016/09/13/jQuery%E6%93%8D%E4%BD%9Cdom%E5%85%83%E7%B4%A0/"/>
    <id>https://feahter.github.io/2016/09/13/jQuery操作dom元素/</id>
    <published>2016-09-13T08:43:07.000Z</published>
    <updated>2016-09-14T06:56:40.370Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.w3school.com.cn/jquery/jquery_ref_manipulation.asp" target="_blank" rel="external">http://www.w3school.com.cn/jquery/jquery_ref_manipulation.asp</a><br>| <a href="http://www.w3school.com.cn/jquery/attributes_addclass.asp" target="_blank" rel="external">addClass()</a> | 向匹配的元素添加指定的类名。              |<br>| —————————————- | ————————— |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_after.asp" target="_blank" rel="external">after()</a> | 在匹配的元素之后插入内容。               |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_append.asp" target="_blank" rel="external">append()</a> | 向匹配的元素内部追加内容。               |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_appendto.asp" target="_blank" rel="external">appendTo()</a> | 向匹配的元素内部追加内容。               |<br>| <a href="http://www.w3school.com.cn/jquery/attributes_attr.asp" target="_blank" rel="external">attr()</a> | 设置或返回匹配元素的属性和值。             |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_before.asp" target="_blank" rel="external">before()</a> | 在每个匹配的元素之前插入内容。             |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_clone.asp" target="_blank" rel="external">clone()</a> | 创建匹配元素集合的副本。                |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_detach.asp" target="_blank" rel="external">detach()</a> | 从 DOM 中移除匹配元素集合。            |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_empty.asp" target="_blank" rel="external">empty()</a> | 删除匹配的元素集合中所有的子节点。           |<br>| <a href="http://www.w3school.com.cn/jquery/attributes_hasclass.asp" target="_blank" rel="external">hasClass()</a> | 检查匹配的元素是否拥有指定的类。            |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_html.asp" target="_blank" rel="external">html()</a> | 设置或返回匹配的元素集合中的 HTML 内容。     |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_insertafter.asp" target="_blank" rel="external">insertAfter()</a> | 把匹配的元素插入到另一个指定的元素集合的后面。     |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_insertbefore.asp" target="_blank" rel="external">insertBefore()</a> | 把匹配的元素插入到另一个指定的元素集合的前面。     |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_prepend.asp" target="_blank" rel="external">prepend()</a> | 向每个匹配的元素内部前置内容。             |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_perpendto.asp" target="_blank" rel="external">prependTo()</a> | 向每个匹配的元素内部前置内容。             |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_remove.asp" target="_blank" rel="external">remove()</a> | 移除所有匹配的元素。                  |<br>| <a href="http://www.w3school.com.cn/jquery/attributes_removeattr.asp" target="_blank" rel="external">removeAttr()</a> | 从所有匹配的元素中移除指定的属性。           |<br>| <a href="http://www.w3school.com.cn/jquery/attributes_removeclass.asp" target="_blank" rel="external">removeClass()</a> | 从所有匹配的元素中删除全部或者指定的类。        |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_replaceall.asp" target="_blank" rel="external">replaceAll()</a> | 用匹配的元素替换所有匹配到的元素。           |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_replacewith.asp" target="_blank" rel="external">replaceWith()</a> | 用新内容替换匹配的元素。                |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_text.asp" target="_blank" rel="external">text()</a> | 设置或返回匹配元素的内容。               |<br>| <a href="http://www.w3school.com.cn/jquery/attributes_toggleclass.asp" target="_blank" rel="external">toggleClass()</a> | 从匹配的元素中添加或删除一个类。            |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_unwrap.asp" target="_blank" rel="external">unwrap()</a> | 移除并替换指定元素的父元素。              |<br>| <a href="http://www.w3school.com.cn/jquery/attributes_val.asp" target="_blank" rel="external">val()</a> | 设置或返回匹配元素的值。                |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_wrap.asp" target="_blank" rel="external">wrap()</a> | 把匹配的元素用指定的内容或元素包裹起来。        |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_wrapall.asp" target="_blank" rel="external">wrapAll()</a> | 把所有匹配的元素用指定的内容或元素包裹起来。      |<br>| <a href="http://www.w3school.com.cn/jquery/manipulation_wrapinner.asp" target="_blank" rel="external">wrapinner()</a> | 将每一个匹配的元素的子内容用指定的内容或元素包裹起来。 |</p>
<p>获取dom获取表单</p>
<p>document.getElementsByTagName（”from”）;</p>
<p>使用dom获取 某元素src属性的方法</p>
<p>element.getAttribute(“src”); </p>
<p>利用jquery操作dom</p>
<ol>
<li>利用jquery进行文档处理</li>
</ol>
<p>2.1：外部插入</p>
<p><strong>after(content)</strong></p>
<p>在每个匹配的元素之后插入内容。</p>
<p>返回值</p>
<p>jQuery</p>
<p>参数</p>
<p>content (String, dom, jQuery) : 插入到每个目标后的内容</p>
<p>示例</p>
<p>在所有段落之后插入一些HTML标记代码。</p>
<p>HTML 代码:</p>
<p>I would like to say: </p>

<p>jQuery 代码:</p>
<p>$(“p”).after(“<b>Hello</b>“);</p>
<p>结果:</p>
<p>I would like to say: </p><b>Hello</b><br><br>在所有段落之后插入一个DOM元素。<br><br>HTML 代码:<br><br><b id="foo">Hello</b><p>I would like to say: </p>

<p>jQuery 代码:</p>
<p><strong>$(“p”).after( $(“#foo”)[0] );//**</strong>将jquery<strong><strong>对象转换为dom</strong></strong>对象$(“#foo”)[0]**</p>
<p>结果:</p>
<p>I would like to say: </p><b id="foo">Hello</b><br><br>在所有段落中后插入一个jQuery对象(类似于一个DOM元素数组)。<br><br>HTML 代码:<br><br><b>Hello</b><p>I would like to say: </p>

<p>jQuery 代码:</p>
<p><strong>$(“p”).after( $(“b”) );</strong></p>
<p>结果:</p>
<p>I would like to say: </p><b>Hello</b><br><br>before(content)在每个匹配的元素之前插入内容。<br><br>返回值<br><br>jQuery<br><br>参数<br><br>content (String, Element, jQuery) : 插入到每个目标前的内容<br><br>示例<br><br>在所有段落之前插入一些HTML标记代码。<br><br>HTML 代码:<br><br><p>I would like to say: </p>

<p>jQuery 代码:</p>
<p>$(“p”).before(“<b>Hello</b>“);</p>
<p>结果:   [ <b>Hello</b></p><p>I would like to say: </p> ]<p></p>
<p>在所有段落之前插入一个元素。</p>
<p>HTML 代码:</p>
<p>I would like to say: </p><b id="foo">Hello</b><br><br>jQuery 代码:<br><br>$(“p”).before( $(“#foo”)[0] );<br><br>结果:<br><br><b id="foo">Hello</b><p>I would like to say: </p>

<p>在所有段落中前插入一个jQuery对象(类似于一个DOM元素数组)。</p>
<p>HTML 代码:</p>
<p>I would like to say: </p><b>Hello</b><br><br>jQuery 代码:<br><br>$(“p”).before( $(“b”) );<br><br>结果:<br><br><b>Hello</b><p>I would like to say: </p>

<p><strong>insertAfter(content)</strong></p>
<p>把所有匹配的元素插入到另一个、指定的元素元素集合的后面。</p>
<p>实际上，使用这个方法是颠倒了常规的$(A).after(B)的操作，即不是把B插入到A后面，而是把A插入到B后面。</p>
<p>返回值jQuery</p>
<p>参数 content (String) : 用于匹配元素的jQuery表达式</p>
<p>示例</p>
<p>在所有段落之后插入一个元素。与 $(“#foo”).after(“p”)相同</p>
<p>HTML 代码:</p>
<p>I would like to say: </p><div id="foo">Hello</div><br><br>jQuery 代码:<br><br>$(“p”).insertAfter($(“#foo“)); <strong> **</strong>在$(“#foo“)<strong>**在它后面插入段落P</strong><br><br>结果:<br><br><div id="foo">Hello</div><p>I would like to say: </p>

<p>insertBefore(content)</p>
<p>把所有匹配的元素插入到另一个、指定的元素元素集合的前面。</p>
<p>实际上，使用这个方法是颠倒了常规的$(A).before(B)的操作，即不是把B插入到A前面，而是把A插入到B前面。</p>
<p>返回值jQuery</p>
<p>参数 content (String) : 用于匹配元素的jQuery表达式</p>
<p>示例</p>
<p>在所有段落之前插入一个元素。与 $(“#foo”).before(“p”)相同。</p>
<p>HTML 代码:</p>
<div id="foo">Hello</div><p>I would like to say: </p><br><br>jQuery 代码:<br><br>$(“p”).insertBefore($(“#foo“));   在$(“#foo“)前面插入段落p<br><br>结果:<br><br><p>I would like to say: </p><div id="foo">Hello</div>



<p>2.2: 内部插入</p>
<p><strong>append(content)</strong></p>
<p>向每个匹配的元素内部追加内容。</p>
<p>这个操作与对指定的元素执行appendChild方法，将它们添加到文档中的情况类似。</p>
<p>返回值jQuery</p>
<p><strong>参数 content (String, Element, jQuery) : **</strong>要追加到目标中的内容**</p>
<p>示例 ：向所有段落中追加一些HTML标记。</p>
<p>HTML 代码:</p>
<p>I would like to say: </p>

<p>jQuery 代码:</p>
<p>$(“p”).append(“<b>Hello</b>“);   <strong>在p**</strong>元素之间插入 b<strong>**元素</strong></p>
<p>结果:</p>
<p>[ </p><p>I would like to say: <b>Hello</b></p> ]<p></p>
<p>appendTo(content)</p>
<p>把所有匹配的元素追加到另一个、指定的元素元素集合中。</p>
<p>实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。</p>
<p>返回值jQuery</p>
<p>参数content (String) :用于被追加的内容</p>
<p>示例</p>
<p>把所有段落追加到ID值为foo的元素中。</p>
<p>HTML 代码:</p>
<p>I would like to say: </p><div id="foo"></div><br><br>jQuery 代码:<br><br>$(“p”).appendTo($(“#foo“)); <strong>P**</strong>元素被添加到div<strong><strong>元素#foo</strong></strong>之中<strong><br><br>结果:<br><br><div id="foo"><p>I would like to say: </p></div>

</strong>prepend(content)**<br><br>向每个匹配的元素内部前置内容。<br><br>这是向所有匹配元素内部的开始处插入内容的最佳方式。<br><br>返回值jQuery<br><br>参数content (String, Element, jQuery) : 要插入到目标元素内部前端的内容<br><br>示例<br><br>向所有段落中前置一些HTML标记代码。<br><br>HTML 代码:<br><br><p>I would like to say: </p>

<p>jQuery 代码:</p>
<p>$(“p”).prepend(“<b>Hello</b>“);   //将<b>Hello</b>添加到p标签内容前</p>
<p>结果:</p>
<p>[ </p><p><b>Hello</b>I would like to say: </p> ]<p></p>
<p>将一个DOM元素前置入所有段落</p>
<p>HTML 代码:</p>
<p>I would like to say: </p><br><p>I would like to say: </p><br><b class="foo">Hello</b><br><b class="foo">Good Bye</b><br><br>jQuery 代码:<br><br>$(“p”).prepend( $(“.foo”)[0] );<br><br>结果:<br><br><p><b class="foo">Hello</b>I would like to say: </p><br><p><b class="foo">Hello</b>I would like to say: </p><br><b class="foo">Hello</b><br><b class="foo">Good Bye</b><br><br>向所有段落中前置一个jQuery对象(类似于一个DOM元素数组)。<br><br>HTML 代码:<br><br><p>I would like to say: </p><b>Hello</b><br><br>jQuery 代码:<br><br>$(“p”).prepend( $(“b”) );<br><br>结果:<br><br><p><b>Hello</b>I would like to say: </p>

<p><strong>prependTo(content)</strong></p>
<p>把所有匹配的元素前置到另一个、指定的元素元素集合中。</p>
<p>实际上，使用这个方法是颠倒了常规的$(A).prepend(B)的操作，即不是把B前置到A中，而是把A前置到B中。</p>
<p>返回值jQuery</p>
<p>参数content (String) :用于匹配元素的jQuery表达式</p>
<p>示例</p>
<p>把所有段落追加到ID值为foo的元素中。</p>
<p>HTML 代码:</p>
<p>I would like to say: </p><div id="foo"></div><br><br>jQuery 代码:<br><br>$(“p”).prependTo($(“#foo“));  <strong>把所有段落插入到div foo**</strong>中<strong><br><br>结果:<br><br><div id="foo"><p>I would like to say: </p></div> 2.3:

</strong>包裹<strong>**</strong><br><br>}       <strong>wrap(html)</strong><br><br>把所有匹配的元素用其他元素的结构化标记包裹起来。<br><br>这种包装对于在文档中插入额外的结构化标记最有用，而且它不会破坏原始文档的语义品质。 这个函数的原理是检查提供的第一个元素（它是由所提供的HTML标记代码动态生成的），并在它的代码结构中找到最上层的祖先元素－－这个祖先元素就是包裹元素。<br><br><br><br>当HTML标记代码中的元素包含文本时无法使用这个函数。因此，如果要添加文本应该在包裹完成之后再行添加。<br><br>返回值jQuery<br><br>参数<br><br>html (String) : HTML标记代码字符串，用于动态生成元素并包裹目标元素<br><br>示例<br><br>把所有的段落用一个新创建的div包裹起来<br><br>HTML 代码:<br><br><p>Test Paragraph.</p>

<p>jQuery 代码:</p>
<p>$(“p”).wrap(“<div class="wrap"></div>“); 段落P用div class=’wrap’包裹起来</p>
<p>结果:</p>
<p><strong>Test Paragraph.</strong></p>
<p>wrap(elem)</p>
<p>把所有匹配的元素用其他元素的结构化标记包装起来。</p>
<p>返回值jQuery</p>
<p>参数elem (Element) : 用于包装目标元素的DOM元素</p>
<p>}         示例</p>
<p>}         用ID是”content”的div将每一个段落包裹起来</p>
<p>}         HTML 代码:</p>
<p>}         </p><p>Test Paragraph.</p><div id="content"></div><p></p>
<p>}         jQuery 代码:</p>
<p>}         $(“p”).wrap(document.getElementById(‘content’));</p>
<p>}         结果:</p>
<p>}         <div id="content"><p>Test Paragraph.</p></div><div id="content"></div></p>
<p><strong>wrapAll(html)</strong></p>
<p>将所有匹配的元素用单个元素包裹起来</p>
<p>这于 ‘.wrap()’ 是不同的，’.wrap()’为每一个匹配的元素都包裹一次。 这种包装对于在文档中插入额外的结构化标记最有用，而且它不会破坏原始文档的语义品质。</p>
<p>这个函数的原理是检查提供的第一个元素并在它的代码结构中找到最上层的祖先元素－－这个祖先元素就是包装元素。</p>
<p>返回值jQuery</p>
<p>参数html (String) : TML标记代码字符串，用于动态生成元素并包装目标元素</p>
<p>示例</p>
<p>用一个生成的div将所有段落包裹起来</p>
<p>}         HTML 代码:</p>
<p>}         </p><p>Hello</p><p>cruel</p><p>World</p><p></p>
<p>}         jQuery 代码:</p>
<p>}         $(“p”).wrapAll(“<div></div>“);  //如果是wrap 则 每个段落P都被div包裹</p>
<p>}         结果:</p>
<p>}         <div><p>Hello</p><p>cruel</p><p>World</p></div></p>
<p><strong>wrapAll(elem)</strong></p>
<p>将所有匹配的元素用单个元素包裹起来</p>
<p>这于 ‘.wrap()’ 是不同的，’.wrap()’为每一个匹配的元素都包裹一次。</p>
<p>返回值jQuery</p>
<p>参数elem (Element) : 用于包装目标元素的DOM元素</p>
<p>示例</p>
<p>用一个生成的div将所有段落包裹起来</p>
<p>HTML 代码:</p>
<p>Hello</p><p>cruel</p><p>World</p>

<p>jQuery 代码:</p>
<p>$(“p”).wrapAll(document.createElement(“div”));</p>
<p>结果:</p>
<div><p>Hello</p><p>cruel</p><p>World</p></div>

<p><strong>wrapInner(html)</strong></p>
<p>将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来</p>
<p>这个函数的原理是检查提供的第一个元素（它是由所提供的HTML标记代码动态生成的），并在它的代码结构中找到最上层的祖先元素－－这个祖先元素就是包装元素。</p>
<p>返回值jQuery</p>
<p>参数html (String) : HTML标记代码字符串，用于动态生成元素并包装目标元素</p>
<p>示例</p>
<p>把所有段落内的每个子内容加粗</p>
<p>HTML 代码:</p>
<p>Hello</p><p>cruel</p><p>World</p>

<p>jQuery 代码:</p>
<p>$(“p”).wrapInner(“<b></b>“);</p>
<p>结果:</p>
<p><b>Hello</b></p><p><b>cruel</b></p><p><b>World</b></p>

<p><strong>wrapInner(elem)</strong></p>
<p>将每一个匹配的元素的子内容(包括文本节点)用DOM元素包裹起来</p>
<p>返回值jQuery</p>
<p>参数elem (Element) : 用于包装目标元素的DOM元素</p>
<p>示例</p>
<p>把所有段落内的每个子内容加粗</p>
<p>HTML 代码:</p>
<p>Hello</p><p>cruel</p><p>World</p>

<p>jQuery 代码:</p>
<p>$(“p”).wrapInner(document.createElement(“b”));</p>
<p>结果:</p>
<p><b>Hello</b></p><p><b>cruel</b></p><p><b>World</b></p>









<p><strong>2.4: **</strong>替换<strong>**</strong></p>
<p><strong>replaceWith(content)</strong></p>
<p>将所有匹配的元素替换成指定的HTML或DOM元素。</p>
<p>返回值</p>
<p>jQuery</p>
<p>参数</p>
<p>content (String, Element, jQuery) : 用于将匹配元素替换掉的内容</p>
<p>示例</p>
<p>把所有的段落标记替换成加粗的标记。</p>
<p>HTML 代码:</p>
<p>Hello</p><p>cruel</p><p>World</p>

<p>jQuery 代码:</p>
<p>$(“p”).replaceWith(“<b>Paragraph. </b>“);</p>
<p>结果:</p>
<p><b>Paragraph. </b><b>Paragraph. </b><b>Paragraph. </b></p>
<p><strong>replaceAll(selector) **</strong>去替换<strong>**</strong></p>
<p>用匹配的元素替换掉所有 selector匹配到的元素。</p>
<p>返回值jQuery</p>
<p>参数selector (选择器) : 用于查找<strong>所要被替换的元素</strong></p>
<p>示例</p>
<p>把所有的段落标记替换成加粗标记</p>
<p>HTML 代码:</p>
<p>Hello</p><p>cruel</p><p>World</p>

<p>jQuery 代码:</p>
<p>$(“<b>Paragraph. </b>“).replaceAll(“p”);  </p>
<p>结果:</p>
<p><b>Paragraph. </b><b>Paragraph. </b><b>Paragraph. </b></p>
<p><strong>2.5: **</strong>删除<strong>**</strong></p>
<p>}       <strong>empty()</strong></p>
<p>删除匹配的元素集合中所有的子节点。</p>
<p>返回值jQuery</p>
<p>示例把所有段落的子元素（包括文本节点）删除</p>
<p>HTML 代码:</p>
<p>Hello, <span>Person</span> <a href="#">and person</a></p>

<p>jQuery 代码:</p>
<p>$(“p”).empty();  <strong>删除p**</strong>中所有内容**</p>
<p>结果:</p>
<p></p>



<p><strong>remove([expr])</strong></p>
<p>从DOM中删除所有匹配的元素。</p>
<p>这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。</p>
<p>返回值jQuery</p>
<p>参数expr (String) : (可选) 用于筛选元素的jQuery表达式</p>
<p>示例从DOM中把所有段落删除</p>
<p>HTML 代码:</p>
<p>Hello</p> how are <p>you?</p>

<p>jQuery 代码:</p>
<p>$(“p”).remove(); <strong>//**</strong>移除p<strong>**标签</strong></p>
<p>结果:</p>
<p>how are</p>
<p>从DOM中把带有hello类的段落删除</p>
<p>}         HTML 代码:</p>
<p>}         </p><p class="hello">Hello</p> how are <p>you?</p><p></p>
<p>}         jQuery 代码:</p>
<p>}         $(“p”).remove(“.hello”);</p>
<p>}         结果:</p>
<p>}         how are </p><p>you?</p><p></p>
<p><strong>2.6: **</strong>复制<strong>**</strong></p>
<p><strong>clone()</strong></p>
<p>克隆匹配的DOM元素并且选中这些克隆的副本。</p>
<p>在想把DOM文档中元素的副本添加到其他位置时这个函数非常有用。</p>
<p>返回值jQuery</p>
<p>示例克隆所有b元素（并选中这些克隆的副本），然后将它们前置到所有段落中。</p>
<p>HTML 代码:</p>
<p><b>Hello</b></p><p>, how are you?</p><p></p>
<p>jQuery 代码:</p>
<p>$(“b”).clone().prependTo(“p”);  <strong>将b**</strong>标签赋值到p<strong><strong>标签中,</strong></strong>没有clone <strong>**就会直接插入到p</strong></p>
<p>结果:</p>
<p><b>Hello</b></p><p><b>Hello</b>, how are you?</p><p></p>
<hr>
<hr>
<hr>
<hr>
<hr>
<p><strong>clone(true)</strong></p>
<p>元素以及其所有的事件处理并且选中这些克隆的副本</p>
<p>在想把DOM文档中元素的副本添加到其他位置时这个函数非常有用。</p>
<p>返回值jQuery</p>
<p><strong>参数true (Boolean) : **</strong>设置为true<strong>**以便复制元素的所有事件处理</strong></p>
<p>示例</p>
<p>创建一个按钮，他可以复制自己，并且他的副本也有同样功能。</p>
<p>HTML 代码:</p>
<button>Clone Me!</button>

<p>jQuery 代码:</p>
<p>$(“button”).click(function(){<br>  $(this).clone(true).insertAfter(this);</p>
<p><strong>//**</strong>复制 <strong><strong>当前元素包含他的事件 </strong></strong>并将副本插入到当前元素前面**});</p>
<p>二、jQuery遍历与查找节点</p>
<p>Ø       过滤</p>
<p>Ø       查找</p>
<p>Ø       串联</p>
<p>1.1、jQuery过滤</p>
<p><strong>eq(index)**</strong>获取第N<strong>**个元素</strong></p>
<p>这个元素的位置是从0算起。</p>
<p>返回值jQuery</p>
<p>参数index (Integer) :元素在jQuery对象中的索引</p>
<p>示例</p>
<p>获取匹配的第二个元素</p>
<p>HTML 代码:</p>
<p> This is just a test.</p> <p> So is this</p>

<p>jQuery 代码:</p>
<p>$(“p”).eq(1)</p>
<p>结果:</p>
<p>[ </p><p> So is this</p> ]<p></p>
<p><strong>hasClass(class) **</strong>查找类**</p>
<p>检查当前的元素是否含有某个特定的类，如果有，则返回true。</p>
<p>这其实就是 is(“.” + class)。</p>
<p>返回值Boolean</p>
<p>参数class (String) : 用于匹配的类名</p>
<p>示例：给包含有某个类的元素进行一个动画。</p>
<p>HTML 代码:</p>
<div class="protected"></div><div></div>

<p>jQuery 代码:</p>
<p>$(“div”).click(function(){<br>  if ( $(this).hasClass(“protected”) )<br>    $(this)<br>      .animate({ left: -10 })<br>      .animate({ left: 10 })<br>      .animate({ left: -10 })<br>      .animate({ left: 10 })<br>      .animate({ left: 0 });<br>});</p>
<p><strong>is(expr)</strong></p>
<p>用一个表达式来检查当前选择的元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。</p>
<p>如果没有元素符合，或者表达式无效，都返回’false’. ‘filter’ 内部实际也是在调用这个函数，所以，filter()函数原有的规则在这里也适用。</p>
<p>返回值Boolean</p>
<p>参数expr (String) :用于筛选的表达式</p>
<p>示例：由于input元素的父元素是一个表单元素，所以返回true。</p>
<p>HTML 代码:</p>
 <form><input type="checkbox"></form>

<p>jQuery 代码:</p>
<p>$(“input[type=’checkbox’]”).parent().is(“form”) // parent()父元素</p>
<p>结果:</p>
<p>true</p>
<p>1.2、jQuery查找</p>
<p><strong>find(expr)</strong></p>
<p>搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。</p>
<p>所有搜索都依靠jQuery表达式来完成。这个表达式可以使用CSS1-3的选择器语法来写。</p>
<p>返回值jQuery</p>
<p>参数：expr (String) :用于查找的表达式</p>
<p>示例：从所有的段落开始，进一步搜索下面的span元素。与$(“p span”)相同。</p>
<p>}         HTML 代码:</p>
<p>}         </p><p><span>Hello</span>, how are you?</p><p></p>
<p>}         jQuery 代码:</p>
<p>}         $(“p”).find(“span”)</p>
<p>}         结果:</p>
<p>}         [ <span>Hello</span> ]</p>
<p><strong>next([expr])</strong></p>
<p>取得一个包含匹配的元素集合中每一个元素<strong>紧邻的后面同辈</strong>元素的元素集合。</p>
<p>这个函数只返回后面那个紧邻的同辈元素，而不是后面<strong>所有的同辈元素（可以使用**</strong>nextAll<strong>**）。</strong>可以用一个可选的表达式进行筛选。</p>
<p>返回值jQuery</p>
<p>参数expr (String) : (可选) 用于筛选的表达式</p>
<p>}         示例找到每个段落的后面紧邻的同辈元素。</p>
<p>}         HTML 代码:</p>
<p>}         </p><p>Hello</p><p>Hello Again</p><div><span>And Again</span></div><p></p>
<p>}         jQuery 代码:</p>
<p>}         $(“p”).next()</p>
<p>}         结果:</p>
<p>}         [ </p><p>Hello Again</p>, <div><span>And Again</span></div> ]<p></p>
<p><strong>找到每个段落的后面紧邻的同辈元素中类名为selected**</strong>的元素。**</p>
<p>}         HTML 代码:</p>
<p>}         </p><p>Hello</p><p class="selected">Hello Again</p><div><span>And Again</span></div><p></p>
<p>}         jQuery 代码:</p>
<p>}         $(“p”).next(“.selected”)</p>
<p>}         结果:</p>
<p>}         [ </p><p class="selected">Hello Again</p> ]<p></p>
<p><strong>1.3**</strong>、<strong><strong>jQuery</strong></strong>串联<strong>**</strong></p>
<p>}       <strong>andSelf()</strong></p>
<p><strong>加入先前所选的加入当前元素中</strong></p>
<p><strong>对于筛选或查找后的元素，要加入先前所选元素时将会很有用。</strong></p>
<p>返回值jQuery</p>
<p>示例:选取所有div以及内部的p，并加上border类</p>
<p>HTML 代码:</p>
<div><p>First Paragraph</p><p>Second Paragraph</p></div>

<p>jQuery 代码:</p>
<p>$(“div”).find(“p”).andSelf().addClass(“border”);</p>
<p>//div中寻找段落P，和他自己（andSelf）加类class=”border”</p>
<p>结果:</p>
<div class="border"><p class="border">First Paragraph</p><p class="border">Second Paragraph</p></div>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.w3school.com.cn/jquery/jquery_ref_manipulation.asp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.w3school.com.cn/jquery/
    
    </summary>
    
      <category term="术" scheme="https://feahter.github.io/categories/%E6%9C%AF/"/>
    
    
      <category term="jQuery" scheme="https://feahter.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>jQuery 的选择器</title>
    <link href="https://feahter.github.io/2016/09/13/jQuery%20%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>https://feahter.github.io/2016/09/13/jQuery 的选择器/</id>
    <published>2016-09-13T07:42:13.000Z</published>
    <updated>2016-09-14T06:56:39.046Z</updated>
    
    <content type="html"><![CDATA[<p>jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 </p>
<p>$(“#myELement”)    选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素<br>$(“div”)           选择所有的div标签元素，返回div元素数组<br>$(“.myClass”)      选择使用myClass类的css的所有元素<br>$(“<em>“)             选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$(“#myELement,div,.myclass”)<br>层叠选择器：<br>$(“form input”)         选择所有的form元素中的input元素<br>$(“#main &gt; </em>“)          选择id值为main的所有的子元素<br>$(“label + input”)     选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素<br>$(“#prev ~ div”)       同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 </p>
<p>基本过滤选择器：<br>$(“tr:first”)               选择所有tr元素的第一个<br>$(“tr:last”)                选择所有tr元素的最后一个<br>$(“input:not(:checked) + span”)   </p>
<p>过滤掉：checked的选择器的所有的input元素 </p>
<p>$(“tr:even”)               选择所有的tr元素的第0，2，4… …个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） </p>
<p>$(“tr:odd”)                选择所有的tr元素的第1，3，5… …个元素<br>$(“td:eq(2)”)             选择所有的td元素中序号为2的那个td元素<br>$(“td:gt(4)”)             选择td元素中序号大于4的所有td元素<br>$(“td:ll(4)”)              选择td元素中序号小于4的所有的td元素<br>$(“:header”)<br>$(“div:animated”)<br>内容过滤选择器： </p>
<p>$(“div:contains(‘John’)”) 选择所有div中含有John文本的元素<br>$(“td:empty”)           选择所有的为空（也不包括文本节点）的td元素的数组<br>$(“div:has(p)”)        选择所有含有p标签的div元素<br>$(“td:parent”)          选择所有的以td为父节点的元素数组<br>可视化过滤选择器： </p>
<p>$(“div:hidden”)        选择所有的被hidden的div元素<br>$(“div:visible”)        选择所有的可视化的div元素<br>属性过滤选择器： </p>
<p>$(“div[id]”)              选择所有含有id属性的div元素<br>$(“input[name=’newsletter’]”)    选择所有的name属性等于’newsletter’的input元素 </p>
<p>$(“input[name!=’newsletter’]”) 选择所有的name属性不等于’newsletter’的input元素 </p>
<p>$(“input[name^=’news’]”)         选择所有的name属性以’news’开头的input元素<br>$(“input[name$=’news’]”)         选择所有的name属性以’news’结尾的input元素<br>$(“input[name*=’man’]”)          选择所有的name属性包含’news’的input元素 </p>
<p>$(“input[id][name$=’man’]”)    可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 </p>
<p>子元素过滤选择器： </p>
<p>$(“ul li:nth-child(2)”),$(“ul li:nth-child(odd)”),$(“ul li:nth-child(3n + 1)”) </p>
<p>$(“div span:first-child”)          返回所有的div元素的第一个子节点的数组<br>$(“div span:last-child”)           返回所有的div元素的最后一个节点的数组<br>$(“div button:only-child”)       返回所有的div中只有唯一一个子节点的所有子节点的数组 </p>
<p>表单元素选择器： </p>
<p>$(“:input”)                  选择所有的表单输入元素，包括input, textarea, select 和 button </p>
<p>$(“:text”)                     选择所有的text input元素<br>$(“:password”)           选择所有的password input元素<br>$(“:radio”)                   选择所有的radio input元素<br>$(“:checkbox”)            选择所有的checkbox input元素<br>$(“:submit”)               选择所有的submit input元素<br>$(“:image”)                 选择所有的image input元素<br>$(“:reset”)                   选择所有的reset input元素<br>$(“:button”)                选择所有的button input元素<br>$(“:file”)                     选择所有的file input元素<br>$(“:hidden”)               选择所有类型为hidden的input元素或表单的隐藏域 </p>
<p>表单元素过滤选择器： </p>
<p>$(“:enabled”)             选择所有的可操作的表单元素<br>$(“:disabled”)            选择所有的不可操作的表单元素<br>$(“:checked”)            选择所有的被checked的表单元素<br>$(“select option:selected”) 选择所有的select 的子元素中被selected的元素 </p>
<p>选取一个 name 为”S_03_22″的input text框的上一个td的text值<br>$(”input[@ name =S_03_22]“).parent().prev().text() </p>
<p>名字以”S_”开始，并且不是以”_R”结尾的值</p>
<p>$(“ input[@ name ^=’ S_’]”).not(“[@ <code>name $=&#39;_R</code>‘]”) </p>
<p>一个名为 radio_01的radio所选的值<br>$(”input[@ name =radio_01][@checked]“).val(); </p>
<p>$(“A B”) 查找A元素下面的所有子节点，包括非直接子节点<br>$(“A&gt;B”) 查找A元素下面的直接子节点<br>$(“A+B”) 查找A元素后面的兄弟节点，包括非直接子节点<br>$(“A~B”) 查找A元素后面的兄弟节点，不包括非直接子节点 </p>
<ol>
<li>$(“A B”) 查找A元素下面的所有子节点，包括非直接子节点 </li>
</ol>
<p>例子：找到表单中所有的 input 元素 </p>
<p>HTML 代码: </p>
<p><form></form></p>
<p><label>Name:</label></p>
<p><input name="name"></p>
<p><fieldset><br>      <label>Newsletter:</label><br>      <input name="newsletter"><br></fieldset><br></p>
<p><input name="none"><br>jQuery 代码: </p>
<p>$(“form input”)<br>结果: </p>
<p>[ <input name="name">, <input name="newsletter"> ] </p>
<ol>
<li>$(“A&gt;B”) 查找A元素下面的直接子节点<br>例子：匹配表单中所有的子级input元素。 </li>
</ol>
<p>HTML 代码: </p>
<p><form></form></p>
<p><label>Name:</label></p>
<p><input name="name"></p>
<p><fieldset><br>      <label>Newsletter:</label><br>      <input name="newsletter"><br></fieldset><br></p>
<p><input name="none"><br>jQuery 代码: </p>
<p>$(“form &gt; input”)<br>结果: </p>
<p>[ <input name="name"> ] </p>
<ol>
<li>$(“A+B”) 查找A元素后面的兄弟节点，包括非直接子节点<br>例子：匹配所有跟在 label 后面的 input 元素 </li>
</ol>
<p>HTML 代码: </p>
<p><form></form></p>
<p><label>Name:</label></p>
<p><input name="name"></p>
<p><fieldset><br>      <label>Newsletter:</label><br>      <input name="newsletter"><br></fieldset><br></p>
<p><input name="none"><br>jQuery 代码: </p>
<p>$(“label + input”)<br>结果: </p>
<p>[ <input name="name">, <input name="newsletter"> ] </p>
<ol>
<li>$(“A~B”) 查找A元素后面的兄弟节点，不包括非直接子节点<br>例子：找到所有与表单同辈的 input 元素 </li>
</ol>
<p>HTML 代码: </p>
<p><form></form></p>
<p><label>Name:</label></p>
<p><input name="name"></p>
<p><fieldset><br>      <label>Newsletter:</label><br>      <input name="newsletter"><br></fieldset><br></p>
<p><input name="none"><br>jQuery 代码: </p>
<p>$(“form ~ input”)<br>结果: </p>
<p>[ <input name="none"> ] </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 &lt;/p&gt;
&lt;p&gt;$(“#myELement”)    选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素&lt;br&gt;$(“div”)
    
    </summary>
    
      <category term="术" scheme="https://feahter.github.io/categories/%E6%9C%AF/"/>
    
    
      <category term="jQuery" scheme="https://feahter.github.io/tags/jQuery/"/>
    
  </entry>
  
</feed>
